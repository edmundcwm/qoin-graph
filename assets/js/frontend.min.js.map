{"version":3,"file":"/assets/js/frontend.min.js","mappings":"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","sources":["webpack://qoin-graph/./assets/js/frontend.js"],"sourcesContent":["/**\n * Core functionality of the Qoin Crypto Pricing Widget.\n */\n\n( function() {\n\tconst currencyDropdown = document.getElementById( 'currency-dropdown' );\n\tconst frequencyToggles = document.querySelectorAll( '[data-frequency]' );\n\tconst errorMessageEl = document.getElementById( 'qg-error' );\n\tconst loader = document.getElementById( 'qg-loader' );\n\tconst chart = document.getElementById( 'qg-chart' );\n\tconst chartBodyEl = document.querySelector( '.qg-chart-wrapper' );\n\tconst appState = {\n\t\tqoinData: {},\n\t\tqoinChart: {}, // we need to store the chart instance for each currency\n\t\tcurrency: currencyDropdown?.value || 'AUD',\n\t\tdataFrequency: 'all', // this needs to be a data attribute on the frequency toggle.\n\t\terror: '',\n\t\tisLoading: false,\n\t};\n\n\tconst frequenciesObj = [\n\t\t// All time. This is a special case. We don't know what the exact number of months to go back to get all data.\n\t\t// The trick is to use a large number so the API will return data from X months ago, which is likely going to be everything.\n\t\tcreateFrequency( 999, 'all' ),\n\t];\n\n\tasync function fetchData( { ...args } ) {\n\t\ttry {\n\t\t\tconst baseUrl = qoinGraphRootUrl; //eslint-disable-line no-undef\n\t\t\tconst endpoint = '/wp-json/qoin-wp/v1/exchange-rate/' + appState.currency; // TODO should this be retrieved from Settings?\n\t\t\tlet requestUrl = baseUrl + endpoint;\n\t\t\t// prepare params for date-based retrieval.\n\t\t\tif ( Object.keys( args ).length ) {\n\t\t\t\tconst params = Object.values( args ).join( '/' );\n\t\t\t\trequestUrl += '/' + params;\n\t\t\t}\n\n\t\t\tconst response = await fetch( requestUrl, {\n\t\t\t\tmethod: 'GET',\n\t\t\t} );\n\n\t\t\tif ( ! response.ok ) {\n\t\t\t\tthrow Error( 'Error fetching data' );\n\t\t\t}\n\t\t\treturn response.json();\n\t\t} catch ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Utility function to retrieve a date based on X number of months before the current date.\n\t *\n\t * @param {number} numOfMonthsPrior - number of months before the current date.\n\t * @return {string|boolean} Start date in yyyy-mm-dd format or false if error.\n\t */\n\tfunction getStartDate( numOfMonthsPrior ) {\n\t\tconst startDate = new Date();\n\t\tconst month = startDate.getMonth() - parseInt( numOfMonthsPrior );\n\n\t\tstartDate.setMonth( month );\n\n\t\t// Ensure startDate is a valid date before formatting it.\n\t\treturn startDate instanceof Date && ! isNaN( startDate ) ? startDate.toISOString().substring( 0, 10 ) : false;\n\t}\n\n\t/**\n\t * Utility function to show element\n\t *\n\t * @param {HTMLElement} el\n\t */\n\tfunction showElement( el ) {\n\t\tel.classList.remove( 'qg-hidden' );\n\t}\n\n\t/**\n\t * Utility function to hide element\n\t *\n\t * @param {HTMLElement} el\n\t */\n\tfunction hideElement( el ) {\n\t\tel.classList.add( 'qg-hidden' );\n\t}\n\n\t/**\n\t * Factory function for creating a frequency object\n\t *\n\t * @param {number} numberOfMonths\n\t * @param {number} id\n\t * @return  {Object} Frequency object\n\t */\n\tfunction createFrequency( numberOfMonths, id ) {\n\t\tconst startDate = getStartDate( numberOfMonths );\n\n\t\tif ( ! startDate ) {\n\t\t\t// TODO: Should we remove the frequency toggle if we can't get a start date?\n\t\t\treturn false;\n\t\t}\n\n\t\tconst frequency = 'day';\n\t\tconst endDate = new Date().toISOString().substring( 0, 10 ); // this locale gives us the date in yyyy-mm-dd\n\n\t\treturn {\n\t\t\tendpointParams: {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\tfrequency,\n\t\t\t},\n\t\t\tid,\n\t\t};\n\t}\n\n\t/**\n\t * Handles storing of data into local storage.\n\t *\n\t * @param {Object} data API response.\n\t */\n\tfunction cacheData( data = {} ) {\n\t\tif ( ! Object.keys( data ).length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlocalStorage.setItem( 'qoinCurrencies', JSON.stringify( data ) );\n\t}\n\n\t/**\n\t * Handles storing of data expiration time in local storage.\n\t * This is used to determine whether to re-fetch data from API.\n\t *\n\t * @param {number} ttl Time to live.\n\t */\n\tfunction setWithExpiry( ttl = 0 ) {\n\t\tconst now = new Date().getTime();\n\n\t\tlocalStorage.setItem( 'qoinCurrencies_expiry', now + ttl );\n\t}\n\n\t/**\n\t * Check whether data in local storage has expired.\n\t */\n\tfunction hasDataExpired() {\n\t\tconst expiry = localStorage.getItem( 'qoinCurrencies_expiry' );\n\t\tconst now = new Date().getTime();\n\n\t\tif ( null === expiry || now >= expiry ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction maybeFetchResources() {\n\t\tappState.error = '';\n\t\tconst { qoinData, currency } = appState;\n\t\tif ( qoinData && currency in qoinData && ! hasDataExpired() ) {\n\t\t\t// Cache is still valid. Don't fetch from API.\n\t\t\trender();\n\t\t\treturn;\n\t\t}\n\n\t\tfetchAllResources();\n\t}\n\n\t// Handles fetching from all API endpoints.\n\tasync function fetchAllResources() {\n\t\tif ( hasDataExpired() ) {\n\t\t\t// Reset state.\n\t\t\tappState.qoinData = {};\n\t\t}\n\n\t\tconst { qoinData, currency } = appState;\n\n\t\ttry {\n\t\t\tappState.isLoading = true;\n\t\t\tappState.error = '';\n\n\t\t\trender();\n\n\t\t\t// Remove frequencies that are invalid then fetch data.\n\t\t\tconst fetchAllData = frequenciesObj.filter( Boolean ).map( function( frequencyParam ) {\n\t\t\t\treturn fetchData( frequencyParam.endpointParams );\n\t\t\t} );\n\n\t\t\tconst responses = await Promise.all( fetchAllData );\n\t\t\tconst formattedResponses = responses.map( function( response ) {\n\t\t\t\treturn formatResponse( response );\n\t\t\t} );\n\n\t\t\tformattedResponses.forEach( ( response, index ) => {\n\t\t\t\tconst frequencyId = frequenciesObj[ index ].id;\n\n\t\t\t\t// Historic values do not give us the current Qoin Price. So we need to append current price to the end of historic values.\n\t\t\t\tconst currentPrice = {\n\t\t\t\t\tvaluationDate: new Date().toISOString(),\n\t\t\t\t\tcurrencyRate: formatPrice( response.current.price ),\n\t\t\t\t};\n\n\t\t\t\tresponse.historic.push( currentPrice );\n\n\t\t\t\t// Update App state.\n\t\t\t\tqoinData[ currency ] = { ...qoinData[ currency ], [ frequencyId ]: response.historic };\n\t\t\t} );\n\n\t\t\t//TODO should not cache empty object.\n\n\t\t\tcacheData( qoinData );\n\n\t\t\t// When fetching new currency we do not want to reset the current cache expiry time.\n\t\t\t// It should only be set if the cache does not exist or if it has already expired.\n\t\t\tif ( ! localStorage.getItem( 'qoinCurrencies_expiry' ) || hasDataExpired() ) {\n\t\t\t// Set a 1 hour expiration for the data in local storage.\n\t\t\t\tsetWithExpiry( 60 * 60 * 1000 );\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\tappState.error = err.message;\n\t\t} finally {\n\t\t\tappState.isLoading = false;\n\n\t\t\trender();\n\t\t}\n\t}\n\n\t/**\n\t * Utility function for formatting response based on specific formatters.\n\t *\n\t * @param {Object} res\n\t * @return {Object} Formatted response\n\t */\n\tfunction formatResponse( res = {} ) {\n\t\tif ( ! Object.keys( res ).length ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst newRes = {};\n\n\t\tconst formatter = {\n\t\t\thistoric: formatHistoricalData,\n\t\t};\n\n\t\tObject.keys( res ).forEach( function( key ) {\n\t\t\tif ( key in formatter ) {\n\t\t\t\tnewRes[ key ] = formatter[ key ]( res[ key ] );\n\t\t\t}\n\t\t} );\n\n\t\treturn { ...res, ...newRes };\n\t}\n\n\t/**\n\t * A utility function to convert a value to 2 decimal places.\n\t *\n\t * @param {string} price\n\t * @return {number} formatted price\n\t */\n\tfunction formatPrice( price ) {\n\t\tif ( typeof price !== 'number' ) {\n\t\t\tprice = parseInt( price );\n\t\t}\n\n\t\t// A few things to do here:\n\t\t// 1. Convert number to a float if necessary.\n\t\tif ( Number.isInteger( price ) ) {\n\t\t\tprice = price / 1000000000000000000;\n\t\t}\n\t\t// 2. Convert float to two decimal places.\n\t\treturn price.toFixed( 3 );\n\t}\n\n\t/**\n\t * Format historical data to desired format.\n\t *\n\t * @param {Array} historical\n\t * @return {Array} modified historical data.\n\t */\n\tfunction formatHistoricalData( historical ) {\n\t\tif ( ! Array.isArray( historical ) ) {\n\t\t\treturn historical;\n\t\t}\n\n\t\t// Remove first item from historical data.\n\t\thistorical.shift();\n\n\t\thistorical = historical.map( function( value ) {\n\t\t\t// All these properties are not in used.\n\t\t\tdelete value.currencyFrom;\n\t\t\tdelete value.exchangeRate;\n\t\t\tdelete value.rangeDate;\n\t\t\tdelete value.rateDate;\n\t\t\tdelete value.tokenValue;\n\n\t\t\tvalue.currencyRate = value.currencyRate.toFixed( 3 ); // format values to three decimal place.\n\n\t\t\treturn value;\n\t\t} );\n\n\t\treturn historical;\n\t}\n\n\t/**\n\t * Render toggle's active/inactive state.\n\t */\n\tfunction renderToggleState() {\n\t\tif ( ! frequencyToggles ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfrequencyToggles.forEach( function( toggle ) {\n\t\t\tif ( appState.dataFrequency === toggle.dataset.frequency ) {\n\t\t\t\ttoggle.classList.add( 'active' );\n\t\t\t} else {\n\t\t\t\ttoggle.classList.remove( 'active' );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render Chart.\n\t */\n\tfunction renderChart() {\n\t\t// hide error\n\t\thideElement( errorMessageEl );\n\t\thideElement( loader );\n\n\t\tif ( 'function' !== typeof Chart ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataSet = [];\n\t\tconst labels = [];\n\t\tconst { dataFrequency, qoinData, currency } = appState;\n\n\t\tif ( ! Object.keys( qoinData ).length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tchartBodyEl.classList.remove( 'qg-hidden' );\n\n\t\t// Chart options.\n\t\tconst options = {\n\t\t\tmaintainAspectRatio: false,\n\t\t\tplugins: {\n\t\t\t\tlegend: {\n\t\t\t\t\tdisplay: false,\n\t\t\t\t},\n\t\t\t\ttooltip: {\n\t\t\t\t\tmode: 'index',\n\t\t\t\t\tintersect: false,\n\t\t\t\t\tdisplayColors: false,\n\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\tlabel( tooltipItem ) {\n\t\t\t\t\t\t\tconst currencySymbol = 'undefined' !== qoinGraphCurrencies && qoinGraphCurrencies[ currency ] ? qoinGraphCurrencies[ currency ] : '$'; //eslint-disable-line no-undef\n\t\t\t\t\t\t\t// Display price in the tooltip.\n\t\t\t\t\t\t\treturn currencySymbol + Number( tooltipItem.formattedValue ); // TODO refactor this. CHeck if qoinGraphCurrencies exist\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\telements: {\n\t\t\t\tpoint: {\n\t\t\t\t\tradius: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tscales: {\n\t\t\t\tx: {\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tmaxTicksLimit: window.matchMedia( '(max-width: 767px)' ).matches ? 5 : 10, // Show 5 labels on Mobile and 10 on Desktop.\n\t\t\t\t\t\tmaxRotation: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ty: {\n\t\t\t\t\ttitle: {\n\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\ttext: 'Qoin Value in ' + currency,\n\t\t\t\t\t},\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tprecision: 2,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst availableData = qoinData?.[ currency ]?.[ dataFrequency ];\n\n\t\tif ( ! availableData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Retrieve historical data from state and use them as datasets.\n\t\tavailableData.forEach( function( data ) {\n\t\t\tdataSet.push( data.currencyRate );\n\n\t\t\t// Retrieve date from ISOString format and use it as label.\n\t\t\tconst date = new Date( data.valuationDate.split( 'T' )[ 0 ] );\n\t\t\tif ( ! ( date instanceof Date ) || isNaN( date ) ) {\n\t\t\t\t// Should display error here?\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Format to use for date - 30 Apr 22.\n\t\t\tconst localeDate = date.toLocaleString( 'default', { year: '2-digit', month: 'short', day: 'numeric' } );\n\t\t\tconst dateElementsArr = localeDate.split( ' ' );\n\t\t\tconst formattedDate = [ dateElementsArr[ 0 ] + ' ' + dateElementsArr[ 1 ], dateElementsArr[ 2 ] ]; // Results in a line break i.e., 3 May <br> 22.\n\n\t\t\tlabels.push( formattedDate );\n\t\t} );\n\n\t\t// Update chart with new data if Chart has already been drawn.\n\t\tif ( appState.qoinChart instanceof Chart ) { // eslint-disable-line no-undef\n\t\t\tappState.qoinChart.data.datasets[ 0 ].data = dataSet;\n\t\t\tappState.qoinChart.data.labels = labels;\n\n\t\t\tappState.qoinChart.options = options;\n\n\t\t\tappState.qoinChart.update();\n\t\t\treturn;\n\t\t}\n\n\t\t// Initialise Chart.\n\t\tappState.qoinChart = new Chart( chart, { //eslint-disable-line no-undef\n\t\t\ttype: 'line',\n\t\t\tdata: {\n\t\t\t\tlabels,\n\t\t\t\tdatasets: [ {\n\t\t\t\t\tdata: dataSet,\n\t\t\t\t\tborderColor: '#197a83',\n\t\t\t\t\tlineTension: 0.4,\n\t\t\t\t\tborderWidth: 2,\n\t\t\t\t\tpointBackgroundColor: '#197a83',\n\t\t\t\t} ],\n\t\t\t},\n\t\t\toptions,\n\t\t} );\n\t}\n\n\t/**\n\t * Render loading state.\n\t */\n\tfunction renderLoading() {\n\t\tshowElement( loader );\n\t\thideElement( chartBodyEl );\n\t\thideElement( errorMessageEl );\n\t}\n\n\t/**\n\t * Render error state.\n\t */\n\tfunction renderError() {\n\t\terrorMessageEl.textContent = appState.error;\n\t\tshowElement( errorMessageEl );\n\t\thideElement( loader );\n\t\thideElement( chartBodyEl );\n\t}\n\n\tfunction render() {\n\t\tif ( appState.isLoading ) {\n\t\t\t// Loading state.\n\t\t\trenderLoading();\n\t\t\treturn;\n\t\t}\n\t\tif ( appState.error ) {\n\t\t\t// Error state.\n\t\t\trenderError();\n\t\t\treturn;\n\t\t}\n\n\t\trenderToggleState();\n\t\trenderChart();\n\t}\n\n\t// Event handler for frequency toggle.\n\tfunction handleFrequencyToggle() {\n\t\tif ( ! frequencyToggles ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfrequencyToggles.forEach( function( toggle ) {\n\t\t\t// Set active toggle based on default frequency on initial load.\n\t\t\trenderToggleState();\n\n\t\t\ttoggle.addEventListener( 'click', function( e ) {\n\t\t\t\te.preventDefault();\n\t\t\t\t// Update dataFrequency state.\n\t\t\t\tappState.dataFrequency = this.dataset.frequency;\n\n\t\t\t\trender();\n\t\t\t} );\n\t\t} );\n\t}\n\n\tfunction handleCurrencyChange() {\n\t\tcurrencyDropdown.addEventListener( 'change', function() {\n\t\t\tappState.currency = this.value;\n\n\t\t\tmaybeFetchResources();\n\t\t} );\n\t}\n\n\t/**\n\t * Update state based on cached values.\n\t */\n\tfunction primeStateFromCache() {\n\t\tconst dataFromCache = JSON.parse( localStorage.getItem( 'qoinCurrencies' ) ) || {};\n\t\tappState.qoinData = dataFromCache;\n\t}\n\n\t/**\n\t * Register all event handlers.\n\t */\n\tfunction registerEvents() {\n\t\thandleFrequencyToggle();\n\t\thandleCurrencyChange();\n\t}\n\n\t/**\n\t * Initialise widget.\n\t */\n\tfunction init() {\n\t\tprimeStateFromCache();\n\t\tregisterEvents();\n\t\tmaybeFetchResources();\n\t}\n\n\tinit();\n}() );\n"],"names":["dataFromCache","currencyDropdown","document","getElementById","frequencyToggles","querySelectorAll","errorMessageEl","loader","chart","chartBodyEl","querySelector","appState","qoinData","qoinChart","currency","value","dataFrequency","error","isLoading","frequenciesObj","numberOfMonths","id","startDate","numOfMonthsPrior","Date","month","getMonth","parseInt","setMonth","isNaN","toISOString","substring","getStartDate","endDate","endpointParams","frequency","createFrequency","fetchData","args","baseUrl","qoinGraphRootUrl","endpoint","requestUrl","Object","keys","length","params","values","join","fetch","method","response","ok","Error","json","showElement","el","classList","remove","hideElement","add","cacheData","data","localStorage","setItem","JSON","stringify","setWithExpiry","ttl","now","getTime","hasDataExpired","expiry","getItem","maybeFetchResources","render","fetchAllResources","fetchAllData","filter","Boolean","map","frequencyParam","Promise","all","responses","formatResponse","forEach","index","frequencyId","currentPrice","valuationDate","currencyRate","formatPrice","current","price","historic","push","message","res","newRes","formatter","formatHistoricalData","key","Number","isInteger","toFixed","historical","Array","isArray","shift","currencyFrom","exchangeRate","rangeDate","rateDate","tokenValue","renderToggleState","toggle","dataset","textContent","Chart","dataSet","labels","options","maintainAspectRatio","plugins","legend","display","tooltip","mode","intersect","displayColors","callbacks","label","tooltipItem","qoinGraphCurrencies","formattedValue","elements","point","radius","scales","x","ticks","maxTicksLimit","window","matchMedia","matches","maxRotation","y","title","text","precision","availableData","date","split","dateElementsArr","toLocaleString","year","day","formattedDate","datasets","update","type","borderColor","lineTension","borderWidth","pointBackgroundColor","renderChart","registerEvents","addEventListener","e","preventDefault","this","parse"],"sourceRoot":""}